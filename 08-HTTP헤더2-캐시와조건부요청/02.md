# 2. 검증 헤더와 조건부 요청1

캐시 시간 초과

캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 있을 수 있다.

1. 서버에서 기존 데이터를 변경함
2. 서버에서 기존 데이터를 변경하지 않음

2번의 경우에는 네트워크를 쓰는 게 낭비.

캐시 만료 후에도 서버에서 데이터를 변경하지 않았을 때

데이터를 전송하는 대신에 저장해둔 캐시를 재사용할 수 있다.

단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.

그때 사용 하는 게 검증헤더다.

첫 번째 요청 때 응답 헤더에

```
Last-Modified: 2020년 11월 10일 10:00:00 (데이터가 마지막에 수정된 시간. UTC 형식임 원래)
```

위와 같이 추가하고

응답 결과를 캐시에 저장한다.

두 번째 요청 때 캐시시간 초과했다면

요청을 다시 보낼 때 last-modifed가 있으면

요청 헤더에

```
if-modified-since: UTC 시간
```

서버가 이걸 확인한 다음. 데이터 수정시간과 `if-modified-since`를 비교해서 데이터가 변하지 않았다고 판단한 뒤

304 Not Modified 라는 상태코드를 응답한다.

이때, cache-contral, last-modified그대로 가는데

메세지 바디가 없음.

헤더가 0.1m, 바디가 1.0m이라고 하면 1m를 아낄 수 있음

클라이언트는 이 응답을 확인해서 캐시 저장소에 있는 데이터의 cache-control 갱신 -> 그 다음부터 다시 캐시 사용

`Last-modified`는 검증헤더고, `if-modified-since`는 조건부 요청이다.

### 정리

캐시 유효 시간이 초과해도 서버의 데이터가 갱신되지 않으면

304 Not Modified + 헤더 메타 정보만 응답(바디 안 줘)

클라는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신

클라는 캐시에 저장되어 있는 데이터 재활용

결과적으로 네트워크 다운로드가 발생은 하지만 용량이 적은 헤더 정보만 다운로드

매우 실용적인 해결책
